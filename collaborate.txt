Design decisions:

0. Use seperate classes to represent various structures
- For the purpose of single responsibility, we defined several classes to represent various subway structures like Station, Line, 
  and Connections. In this way, not only we can "use" Station and Line objects in Connection class to specifically make a reference
  to the corresponding structure, but also there is no interfere between different structures (i.e., stations, lines, and Connections
  are independent from each other).

1. Use dictionary to represent the adjacency list
- We chose to use a 2-dimensional dictionary and each station as the key to define an adjacency list that is beneficial for quickly 
  obtaining connection path weight and other important information. A list of connection travel time and corresponding lines can be 
  found in the dictionary's value. This design choice enables us to acquire the path data more quickly and simply by only specifying 
  the two stations as the "index" during the calculation of distances and passing connection information in algorithm.

2. How to select between less travel time and less transfer time for Dijkstra
- Considering that people may prefer a slightly longer trip with less transfers between lines, we decided to calculate the sum
  of travel time and transfer time and pick the route with the lowest summation from all feasible paths. Also, since longer travel time
  often comes with more transfer time, it is fair to simply add them together without leading to significant bias.

3. Use of Prioritized Item
- When using Priority Queue, we use a Prioritized Item class to solve the problem of encoutering same value of key. Since we only need
  to compare the distTo data, Prioritized Item helps us to store the same key element in the Priority Queue instead of keep comparing 
  the value.

4. how astar and dijkstra implement the abstract class (shortestPathAlgo)
- Due to the similarities between A* and dijkstra algorithms (e.g., usage of priotity queue, requirement of start and end station),
  we used a abstract class to reduce the complexy and redundency to define the classes that represent the two specific algorithms.
  This decision also makes adding more algorithms to the system easier, which essentially provides more extendability for our program. 

5. Use class instances rather than station.id and line.id to index dictionaries
- We used concrete Station and Line objects to index relevant dictionaries like edgeTo and dictTo. Even though using their ids may
  be a valid option, using objects to index creates a relatively stable reference to dictionares since integer ids could be mixed
  up with indexes. 

6. Use the physical distance as the heuristic for A* algorithm
- For Dijkstra algorithm, we compute all paths that have similar transfer time and travel time and choose the best one out of them
  by evaluating the total score of transfer time and travel time. On the other hand, for A* algorithm, we decided to use the physical
  distances as the supporting argument as opposed to transfer time considering that A* is more effecient when it heads straight to the 
  destination. A* wastes less time exploring stations that will not be used in the final path as well.

6. Use 192.127 as a factor in the heuristic function for A* algorithm
- The implementation of A* requires a heuristic function that typically calculates the distance from the current station to the final
  station. This is accomplished by using Pythagoras Theorem to find the exact disdtance from two stations. However, in our priority
  queue, the stations are ranked by the travel time between them. Therefore, a convertion needs to be performed to make the heuristic function
  helpful. More details of how this number is obtains can be found above

Split work: 
The group's workload is evenly split, and we typically complete the coding task together. Below is a list indicates how classes implemented 
individually. One person checks and polishes each area individually, and all programmes' integrity is guaranteed collectively. 
Wenyu Yin: 
1. dijkstra
2. line, connection
3. metricsHandler

Xiang Zhang:
1. astar
2. station, itinerary
3. dataLoader

Analysis of benchmark results
1. Execution Time
  The average execution time (running 200 times) of two algorithm are approximately 0.003129ms and 0.001858ms respectively, and Dijkstra 
  has a slower running time. Two algorithm use similar structures that compute and compare the travel cost of each connection to find the 
  shortest path, however Dijkstra visit the same node multiple times in order to get all the applicable connections that take account of
  the transfer times, which slowers the execution time. Conversely, the heuristic function estimates the surplus distance in Astar that 
  helps the algorithm find the optimized path without visiting unnecessary nodes. Therefore, Astar have a siginificant faster running time
  than Dijkstra.
  And considering the change of execution Time depending on the linear distance between start and end station, the graph shows both algorithms'
  general execution times gradually increase as the distance goes up. Since more possibilities and connections can be involved in the path, 
  distance ascending increases the number of nodes visited. But Dijkstra still is remarkable slower than Astar, which is almost twice over.
  The gap between two algorithms' exeuction time becomes larger as the distance increases.
  
2. Explored Stations Used Ratio
- With the help of the heuristic function, A* algorithm goes relatively straight towards the destination rather than exploring almost
  every station like Djkstra. Therefore, A* algorithm wastes less time on exploring edges that are too far from the current path unlike
  Dijkstra. Plus, in A* algorithm, the physical distances between stations are considered as a supporting argument for the "shortest" path
  between two stations, while Dijkstra requires generating all "best" paths so that we can compare the transfer time of paths, which 
  prevents it from terminating immediately at destination and results in a reduction in explored stations used ratio. 

  The result of this benchmark also provides an explaination of the difference between the execution time of Dijkstra and A*: 
  Dijkstra spends more time on performing searches on unused stations, while A* uses its resources more effectively.